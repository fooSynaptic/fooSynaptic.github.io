---
title: "DDIA Part 1：数据系统基础"
date: 2025-12-28T10:01:00+08:00
tags:
  - DDIA
  - 数据库
  - 存储引擎
  - 数据模型
categories:
  - 读书笔记
---

本文是 DDIA 第一部分的读书笔记，涵盖第 1-4 章：可靠性与可扩展性、数据模型、存储引擎、数据编码。

---

## 第1章：可靠性、可扩展性与可维护性

### 数据密集型应用的组成

现代数据密集型应用通常由多个组件组合：

```
┌─────────────────────────────────────────┐
│         数据密集型应用架构               │
├─────────────────────────────────────────┤
│  数据库 → 缓存 → 搜索索引               │
│  流处理 → 批处理 → 消息队列             │
└─────────────────────────────────────────┘
```

### 可靠性 (Reliability)

> 系统在面对故障时仍能正确运行

**故障类型与应对：**

| 故障类型 | 应对策略 |
|----------|----------|
| 硬件故障 | RAID、双电源、多副本 |
| 软件错误 | 测试、隔离、监控、快速重启 |
| 人为错误 | 沙箱环境、灰度发布、快速回滚 |

### 可扩展性 (Scalability)

> 系统应对负载增长的能力

**性能指标**：使用百分位数而非平均值

| 百分位 | 含义 |
|--------|------|
| p50 | 中位数，典型响应时间 |
| p95 | 95%请求快于此值 |
| p99 | 常用于 SLA 标准 |

**扩展策略**：

- **纵向扩展**：使用更强大的机器
- **横向扩展**：使用多台普通机器
- **弹性扩展**：根据负载自动增减资源

### 可维护性 (Maintainability)

| 方面 | 目标 |
|------|------|
| 可操作性 | 运维团队能轻松保持系统运行 |
| 简单性 | 新工程师能快速理解系统 |
| 可演化性 | 能轻松修改和扩展系统 |

---

## 第2章：数据模型与查询语言

### 三种数据模型对比

| 模型 | 特点 | 适用场景 |
|------|------|----------|
| **关系模型** | 结构化、规范化、SQL | 事务处理、复杂查询 |
| **文档模型** | 灵活模式、嵌套结构 | 树状数据、快速迭代 |
| **图模型** | 多对多关系 | 社交网络、知识图谱 |

### 关系模型

```sql
-- 规范化设计：使用外键
CREATE TABLE users (
    user_id INT PRIMARY KEY,
    name VARCHAR(100),
    position_id INT REFERENCES positions(position_id)
);
```

**优势**：数据一致性、灵活查询、事务支持
**局限**：对象-关系阻抗不匹配、模式僵化

### 文档模型

```json
{
  "user_id": 1,
  "name": "张三",
  "positions": [
    {"title": "工程师", "company": "ABC公司"},
    {"title": "技术总监", "company": "XYZ公司"}
  ]
}
```

**Schema-on-read vs Schema-on-write**：

- 关系数据库：写入时验证模式（静态类型）
- 文档数据库：读取时解释结构（动态类型）

### 图模型

```cypher
// Neo4j Cypher 查询
MATCH (alice:Person {name: 'Alice'})-[:FOLLOWS]->()-[:FOLLOWS]->(fof)
RETURN fof.name
```

### 声明式 vs 命令式

| 类型 | 特点 | 示例 |
|------|------|------|
| 声明式 | 描述想要什么结果 | SQL, Cypher |
| 命令式 | 描述如何得到结果 | 编程语言循环 |

---

## 第3章：存储与检索

### 两大存储引擎家族

| 类型 | 优化目标 | 代表产品 |
|------|----------|----------|
| 日志结构 (LSM) | 写入优化 | RocksDB, Cassandra |
| 原地更新 (B-Tree) | 读取优化 | MySQL, PostgreSQL |

### LSM-Tree 结构

```
Level 0 (内存):
┌────────────┐
│  Memtable  │ ← 当前写入（平衡树）
└────────────┘
      ↓ 达到阈值，写入磁盘
Level 1-N (磁盘):
┌────┐ ┌────┐ ┌────┐
│SS1 │ │SS2 │ │SS3 │ ← SSTable（排序键）
└────┘ └────┘ └────┘
```

**读取流程**：Memtable → 最新 SSTable → ... → 最老 SSTable

**优化技术**：
- **布隆过滤器**：快速判断键是否存在
- **压缩策略**：Size-Tiered（写密集）、Leveled（读密集）

### B-Tree 结构

```
              ┌───────────────┐
              │    [30, 70]   │ ← 根节点
              └───────────────┘
             /       │        \
    ┌───────┐  ┌───────────┐  ┌───────┐
    │[10,20]│  │[40,50,60] │  │[80,90]│ ← 叶子节点
    └───────┘  └───────────┘  └───────┘
```

**WAL (预写日志)**：先写日志，再更新数据，保证崩溃恢复

### B-Tree vs LSM-Tree

| 特性 | B-Tree | LSM-Tree |
|------|--------|----------|
| 写入 | 原地更新 | 追加写入 |
| 读取 | 快（一次定位） | 可能检查多个文件 |
| 写放大 | 较低 | 较高（压缩开销） |
| 空间利用 | 可能碎片化 | 更紧凑 |

### OLTP vs OLAP

| 特性 | OLTP | OLAP |
|------|------|------|
| 操作 | 增删改查 | 复杂查询、聚合 |
| 数据量 | GB~TB | TB~PB |
| 用户 | 应用程序 | 分析师 |
| 存储 | 行存储 | 列存储 |

**列存储优势**：只读取需要的列、压缩友好、向量化处理

---

## 第4章：数据编码与演化

### 兼容性概念

```
时间线: v1 ──> v2 ──> v3 ──> v4

后向兼容：新代码能读取旧数据 (v3 读 v1 数据 ✓)
前向兼容：旧代码能读取新数据 (v1 读 v3 数据 ✓)
```

**滚动升级**：新旧版本代码同时运行，需要双向兼容

### 编码格式对比

| 格式 | 可读性 | 空间效率 | 模式演化 |
|------|--------|----------|----------|
| JSON | 高 | 低 | 手动 |
| Protobuf | 无 | 高 | 支持 |
| Thrift | 无 | 高 | 支持 |
| Avro | 无 | 最高 | 支持 |

### Protocol Buffers

```protobuf
message Person {
  required string user_name = 1;
  optional int64 favorite_number = 2;
  repeated string interests = 3;
}
```

**关键规则**：字段名可改，字段标签（数字）不能改

**兼容性规则**：

| 操作 | 后向兼容 | 前向兼容 |
|------|----------|----------|
| 添加可选字段 | ✓ | ✓ |
| 删除可选字段 | ✓ | ✓ |
| 添加必填字段 | ✗ | ✗ |

### Avro

**特点**：读写模式分离，不存储字段标签，更紧凑

```json
{
  "type": "record",
  "name": "Person",
  "fields": [
    {"name": "userName", "type": "string"},
    {"name": "favoriteNumber", "type": ["null", "long"], "default": null}
  ]
}
```

### 数据流模式

| 模式 | 场景 | 兼容性考虑 |
|------|------|-----------|
| 数据库 | 持久存储 | 数据可能比代码更持久 |
| 服务调用 | REST/RPC | API 版本控制 |
| 消息传递 | 队列/Actor | 生产者消费者解耦 |

---

## 本部分要点总结

1. **可靠性、可扩展性、可维护性**是优秀系统的三大支柱
2. **数据模型选择**取决于数据结构和查询需求
3. **LSM-Tree 优化写入，B-Tree 优化读取**
4. **列存储适合 OLAP，行存储适合 OLTP**
5. **二进制编码比 JSON 更紧凑高效**
6. **模式演化需要保证前向和后向兼容**

---

[返回总览](/2025/12/28/DDIA-读书笔记-总览/) | [下一部分：分布式数据](/2025/12/28/DDIA-Part2-分布式数据/)

