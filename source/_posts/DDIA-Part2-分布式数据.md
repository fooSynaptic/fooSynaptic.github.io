---
title: "DDIA Part 2：分布式数据"
date: 2025-12-28T10:02:00+08:00
tags:
  - DDIA
  - 分布式系统
  - 一致性
  - 共识算法
categories:
  - 读书笔记
---

本文是 DDIA 第二部分的读书笔记，涵盖第 5-9 章：数据复制、分区、事务、分布式挑战、一致性与共识。

---

## 第5章：数据复制

### 复制的目的

| 目的 | 说明 |
|------|------|
| 高可用性 | 部分节点故障时系统仍可用 |
| 降低延迟 | 数据放在离用户更近的地方 |
| 提高读吞吐 | 多个副本并行处理读请求 |

### 主从复制

```
客户端 ──写入──> 主节点 ──复制日志──> 从节点1
                              └──> 从节点2
```

**同步 vs 异步复制**：

| 方式 | 优点 | 缺点 |
|------|------|------|
| 同步 | 数据一致 | 延迟高，可用性差 |
| 异步 | 延迟低 | 可能数据丢失 |
| 半同步 | 平衡 | 实现复杂 |

### 复制延迟问题

| 问题 | 说明 | 解决方案 |
|------|------|----------|
| 读己之写 | 写后读可能读到旧数据 | 修改的数据从主节点读 |
| 单调读 | 刷新后可能看到更旧的数据 | 每个用户固定副本 |
| 一致前缀读 | 因果关系被打乱 | 相关写入同一分区 |

### 多主复制

**适用场景**：多数据中心、离线客户端、协作编辑

**写冲突解决**：

| 策略 | 说明 |
|------|------|
| 最后写入胜出 (LWW) | 时间戳最新的覆盖 |
| 合并值 | 如拼接 "A/B" |
| CRDT | 特殊数据结构自动合并 |
| 提示用户 | 类似 Git 冲突 |

### 无主复制 (Dynamo 风格)

**Quorum 公式**：$W + R > N$

```
N=3, W=2, R=2:
写入需要 2 个副本确认
读取需要查询 2 个副本
至少 1 个副本既写入又读取，保证读到最新值
```

---

## 第6章：数据分区

### 分区策略

| 策略 | 优点 | 缺点 |
|------|------|------|
| 按键范围 | 支持范围查询 | 可能热点 |
| 按键哈希 | 分布均匀 | 失去范围查询 |

**一致性哈希**：添加/删除节点只影响相邻区间

### 热点问题

```
明星发微博 → 所有请求发往同一分区
```

**解决方案**：拆分热键（添加随机后缀）、本地缓存、限流

### 二级索引分区

| 类型 | 特点 |
|------|------|
| 本地索引 | 每分区维护自己的索引，查询需 scatter/gather |
| 全局索引 | 索引本身分区，读快写慢（异步更新） |

### 再平衡策略

| 策略 | 说明 | 产品示例 |
|------|------|----------|
| 固定分区数 | 预创建大量分区 | Elasticsearch |
| 动态分区 | 自动拆分合并 | HBase |
| 按节点比例 | 每节点固定分区数 | Cassandra |

### 请求路由

```
方案1: 客户端直连任意节点 → 转发
方案2: 路由层（知道分区映射）
方案3: 客户端感知分区（如使用 ZooKeeper）
```

---

## 第7章：事务

### ACID 特性

| 特性 | 含义 |
|------|------|
| 原子性 | 全部成功或全部失败 |
| 一致性 | 从有效状态到有效状态 |
| 隔离性 | 并发事务互不干扰 |
| 持久性 | 提交后数据不丢失 |

### 隔离级别

| 级别 | 防止问题 |
|------|----------|
| 读已提交 | 脏读、脏写 |
| 快照隔离 | 不可重复读 |
| 串行化 | 所有并发异常 |

### 丢失更新问题

```
事务1: 读取 counter=10     写入 counter=11
事务2:      读取 counter=10        写入 counter=11
期望: 12，实际: 11（事务1的更新丢失）
```

**解决**：原子操作、显式锁定、Compare-and-Set

### 写偏斜

```
医院规则：至少1名医生值班
Alice 查询：2人值班，取消自己
Bob 同时：2人值班，取消自己
结果：无人值班！
```

**解决**：串行化隔离、物化冲突、显式锁定

### 串行化实现

| 方式 | 特点 | 产品 |
|------|------|------|
| 实际串行 | 单线程执行 | Redis, VoltDB |
| 两阶段锁 (2PL) | 读写互斥 | 传统数据库 |
| 串行化快照隔离 (SSI) | 乐观并发 | PostgreSQL 9.1+ |

### 分布式事务 (2PC)

```
阶段1: 协调者 ──准备?──> 所有参与者
阶段2: 协调者 ──提交/回滚──> 所有参与者

问题：协调者故障时参与者阻塞
```

---

## 第8章：分布式系统的挑战

### 部分失效

| 单机系统 | 分布式系统 |
|----------|------------|
| 要么工作要么不工作 | 部分可能工作 |
| 故障通常完全 | 故障通常部分 |

### 不可靠的网络

```
请求可能：丢失、延迟、重复
响应可能：丢失、延迟
无法区分：网络故障 vs 节点故障
```

**超时困境**：太短误判正常节点，太长恢复慢

### 不可靠的时钟

| 时钟类型 | 用途 |
|----------|------|
| 日历时钟 | 当前时间（可能跳跃） |
| 单调时钟 | 测量持续时间（保证递增） |

**LWW 的风险**：时钟不同步导致新数据被旧数据覆盖

### Fencing Token

```
节点A 获取锁 token=33 → 暂停
节点B 获取锁 token=34 → 写入成功
节点A 恢复 token=33 → 被拒绝（33 < 34）
```

### 系统模型

| 时序假设 | 节点故障假设 |
|----------|--------------|
| 同步/部分同步/异步 | 崩溃-停止/崩溃-恢复/拜占庭 |

**正确性**：安全性（坏事不发生） + 活性（好事最终发生）

---

## 第9章：一致性与共识

### 一致性模型

```
弱 ←─────────────────────────────────→ 强

最终一致性    因果一致性    顺序一致性    线性一致性
```

### 线性一致性

> 系统表现得好像只有一个数据副本，所有操作都是原子的

**应用**：分布式锁、领导者选举、唯一性约束

### CAP 定理

$$
\text{网络分区时，一致性与可用性不可兼得}
$$

| 选择 | 含义 |
|------|------|
| CP | 保证一致性，牺牲可用性 |
| AP | 保证可用性，牺牲一致性 |

### 共识问题

> 多个节点就某个值达成一致

**性质**：一致同意、完整性、终止性、有效性

**FLP 不可能定理**：异步系统中存在故障节点时，不存在总能达成共识的算法

### Paxos 算法

```
阶段1 (Prepare):
提议者 ──Prepare(n)──> 接受者
        <──Promise──

阶段2 (Accept):
提议者 ──Accept(n,v)──> 接受者
        <──Accepted──
```

### Raft 算法

**比 Paxos 更易理解**

```
角色：领导者、跟随者、候选人
任期：逻辑时钟，每次选举递增

选举流程：
1. 跟随者超时 → 变候选人
2. 请求投票 → 获多数票
3. 成为领导者 → 复制日志
```

### 共识的应用

| 产品 | 用途 |
|------|------|
| ZooKeeper | 协调服务、配置管理 |
| etcd | Kubernetes 状态存储 |
| Consul | 服务发现 |

---

## 本部分要点总结

1. **复制的核心挑战是处理数据变更**
2. **分区策略需要权衡范围查询和负载均衡**
3. **事务隔离级别是正确性和性能的权衡**
4. **分布式系统的核心挑战是部分失效**
5. **线性一致性是最强保证，但代价高昂**
6. **Raft 比 Paxos 更易理解，适合学习**

---

[上一部分：数据系统基础](/2025/12/28/DDIA-Part1-数据系统基础/) | [返回总览](/2025/12/28/DDIA-读书笔记-总览/) | [下一部分：衍生数据](/2025/12/28/DDIA-Part3-衍生数据/)

